Конкурентность
Go предоставляет средства конкурентного программирования как часть основного языка. Этот урок представляет их и дает некоторые примеры того, как их можно использовать.

Авторы Go
https://golang.org

* Горутины

_Горутина_ — это легковесный поток, управляемый средой выполнения Go.

	go f(x, y, z)

запускает новую горутину, выполняющую

	f(x, y, z)

Вычисление `f`, `x`, `y` и `z` происходит в текущей горутине, а выполнение `f` происходит в новой горутине.

Горутины выполняются в одном адресном пространстве, поэтому доступ к общей памяти должен быть синхронизирован. Пакет [[https://go.dev/pkg/sync/][`sync`]] предоставляет полезные примитивы, хотя они вам не очень понадобятся в Go, так как есть другие примитивы. (См. следующий слайд.)

.play concurrency/goroutines.go

* Каналы

Каналы — это типизированный механизм обмена данными, через который вы можете отправлять и получать значения с помощью оператора канала `<-`.

	ch <- v    // Отправить v в канал ch.
	v := <-ch  // Получить из ch и
	           // присвоить значение v.

(Данные текут в направлении стрелки.)

Как и хэш-таблицы и срезы, каналы должны быть созданы перед использованием:

	ch := make(chan int)

По умолчанию отправка и получение блокируются до тех пор, пока другая сторона не будет готова. Это позволяет горутинам синхронизироваться без явных блокировок или переменных условий.

Пример кода суммирует числа в срезе, распределяя работу между двумя горутинами.
После того, как обе горутины завершили свои вычисления, он вычисляет окончательный результат.

.play concurrency/channels.go

* Буферизованные каналы

Каналы могут быть _буферизованными_. Укажите длину буфера в качестве второго аргумента для `make`, чтобы инициализировать буферизованный канал:

	ch := make(chan int, 100)

Отправка в буферизованный канал блокируется только когда буфер полон. Получение блокируется, когда буфер пуст.

Измените пример, чтобы переполнить буфер, и посмотрите, что произойдет.

.play concurrency/buffered-channels.go

* Range и Close

Отправитель может `close` канал, чтобы указать, что больше не будет отправлено значений. Получатели могут проверить, закрыт ли канал, присвоив второй параметр выражению получения: после

	v, ok := <-ch

`ok` равно `false`, если больше нет значений для получения и канал закрыт.

Цикл `for`i`:=`range`c` получает значения из канала повторно, пока он не будет закрыт.

*Примечание:* Только отправитель должен закрывать канал, никогда получатель. Отправка в закрытый канал вызовет панику.

*Еще одно*примечание:* Каналы не похожи на файлы; вам обычно не нужно их закрывать. Закрытие необходимо только тогда, когда получатель должен быть уведомлен, что больше не будет значений, например, для завершения цикла `range`.

.play concurrency/range-and-close.go

* Select

Оператор `select` позволяет горутине ждать нескольких операций обмена данными.

`select` блокируется до тех пор, пока один из его случаев не сможет выполниться, затем он выполняет этот случай. Он выбирает один случайным образом, если несколько готовы.

.play concurrency/select.go

* Выбор по умолчанию

Случай `default` в `select` выполняется, если никакой другой случай не готов.

Используйте случай `default`, чтобы попытаться отправить или получить без блокировки:

	select {
	case i := <-c:
		// использовать i
	default:
		// получение из c заблокировало бы
	}

.play concurrency/default-selection.go

* Упражнение: Эквивалентные бинарные деревья

Может быть много различных бинарных деревьев с одинаковой последовательностью значений, хранящихся в них. Например, вот два бинарных дерева, хранящих последовательность 1, 1, 2, 3, 5, 8, 13.

.image /tour/static/img/tree.png

Функция для проверки, хранят ли два бинарных дерева одинаковую последовательность, довольно сложна в большинстве языков. Мы будем использовать конкурентность Go и каналы для написания простого решения.

Этот пример использует пакет `tree`, который определяет тип:

	type Tree struct {
		Left  *Tree
		Value int
		Right *Tree
	}


Продолжение описания на [[javascript:click('.next-page')][следующей странице]].

* Упражнение: Эквивалентные бинарные деревья

*1.* Реализуйте функцию `Walk`.

*2.* Протестируйте функцию `Walk`.

Функция `tree.New(k)` создает бинарное дерево со случайной структурой (но всегда отсортированное), содержащее значения `k`, `2k`, `3k`, ..., `10k`.

Создайте новый канал `ch` и запустите обходчик:

	go Walk(tree.New(1), ch)

Затем прочитайте и выведите 10 значений из канала. Это должны быть числа 1, 2, 3, ..., 10.

*3.* Реализуйте функцию `Same`, используя `Walk`, чтобы определить, хранят ли `t1` и `t2` одинаковые значения.

*4.* Протестируйте функцию `Same`.

`Same(tree.New(1),`tree.New(1))` должен возвращать true, а `Same(tree.New(1),`tree.New(2))` должен возвращать false.

Документацию для `Tree` можно найти [[https://godoc.org/golang.org/x/tour/tree#Tree][здесь]].

.play concurrency/exercise-equivalent-binary-trees.go

* sync.Mutex

Мы видели, как каналы отлично подходят для связи между горутинами.

Но что, если нам не нужна связь? Что, если мы просто хотим убедиться, что только
одна горутина может обращаться к переменной в данный момент, чтобы избежать конфликтов?

Эта концепция называется _взаимным исключением_, и обычное название для структуры данных, которая предоставляет это, — _мьютекс_.

Стандартная библиотека Go предоставляет взаимное исключение с помощью
[[https://go.dev/pkg/sync/#Mutex][`sync.Mutex`]] и его двух методов:

- `Lock`
- `Unlock`

Мы можем определить блок кода для выполнения во взаимном исключении, окружив его
вызовами `Lock` и `Unlock`, как показано в методе `Inc`.

Мы также можем использовать `defer`, чтобы убедиться, что мьютекс будет разблокирован, как в методе `Value`.

.play concurrency/mutex-counter.go

* Упражнение: Веб-краулер

В этом упражнении вы будете использовать возможности конкурентности Go для распараллеливания веб-краулера.

Измените функцию `Crawl`, чтобы получать URL параллельно, не получая один и тот же URL дважды.

_Подсказка_: вы можете хранить кэш URL, которые были получены, в хэш-таблице, но хэш-таблицы сами по себе не
безопасны для параллельного использования!

.play concurrency/exercise-web-crawler.go

* Куда идти дальше...

#appengine: Вы можете начать с
#appengine: [[https://go.dev/doc/install/][установки Go]].

#appengine: После того, как Go установлен,
[[https://go.dev/doc/][Документация Go]] — отличное место для
#appengine: продолжения.
начала.
Она содержит справочники, учебники, видео и многое другое.

Чтобы узнать, как организовать и работать с кодом Go, прочитайте [[https://go.dev/doc/code][Как писать код Go]].

Если вам нужна помощь со стандартной библиотекой, см. [[https://go.dev/pkg/][справочник пакетов]]. Для помощи с самим языком вы можете быть удивлены, обнаружив, что [[https://go.dev/ref/spec][Спецификация языка]] вполне читаема.

Чтобы глубже изучить модель конкурентности Go, посмотрите
[[https://www.youtube.com/watch?v=f6kdp27TYZs][Паттерны конкурентности Go]]
([[/talks/2012/concurrency.slide][слайды]])
и
[[https://www.youtube.com/watch?v=QDDwwePbDtw][Продвинутые паттерны конкурентности Go]]
([[/talks/2013/advconc.slide][слайды]])
и прочитайте
[[https://go.dev/doc/codewalk/sharemem/][Общая память через общение]]
codewalk.

Чтобы начать писать веб-приложения, посмотрите
[[https://vimeo.com/53221558][Простая среда программирования]]
([[/talks/2012/simple.slide][слайды]])
и прочитайте
[[https://go.dev/doc/articles/wiki/][Написание веб-приложений]] учебник.

[[https://go.dev/doc/codewalk/functions/][Функции первого класса в Go]] codewalk дает интересную перспективу на типы функций Go.

[[https://go.dev/blog/][Блог Go]] имеет большой архив информативных статей о Go.

Посетите [[https://go.dev/][главную страницу Go]] для получения дополнительной информации.
