Операторы управления потоком: for, if, else, switch и defer
Изучите, как управлять потоком выполнения кода с помощью условий, циклов, оператора switch и отложенных вызовов.

Авторы Go
https://golang.org

* For

В Go есть только одна конструкция цикла — цикл `for`.

Базовый цикл `for` состоит из трех компонентов, разделенных точкой с запятой:

- оператор инициализации: выполняется перед первой итерацией
- условие: вычисляется перед каждой итерацией
- оператор завершения: выполняется в конце каждой итерации

Оператор инициализации часто является коротким объявлением переменной, и
переменные, объявленные там, видны только в области видимости оператора `for`.

Цикл прекратит итерации, как только логическое условие станет равным `false`.

*Примечание:* В отличие от других языков, таких как C, Java или JavaScript, нет скобок
вокруг трех компонентов оператора `for`, а фигурные скобки `{`}` 
всегда обязательны.

.play flowcontrol/for.go

* For (продолжение)

Операторы инициализации и завершения необязательны.

.play flowcontrol/for-continued.go

* For — это "while" в Go

В этом случае можно опустить точки с запятой: в Go `while` из C пишется как `for`.

.play flowcontrol/for-is-gos-while.go

* Бесконечный цикл

Если вы опустите условие цикла, он будет выполняться бесконечно, так что бесконечный цикл выражается компактно.

.play flowcontrol/forever.go

* If

Операторы `if` в Go похожи на циклы `for`; выражение не нужно
окружать скобками `(`)`, но фигурные скобки `{`}` обязательны.

.play flowcontrol/if.go

* If с коротким оператором

Как и `for`, оператор `if` может начинаться с короткого оператора, который выполняется перед условием.

Переменные, объявленные этим оператором, видны только до конца `if`.

(Попробуйте использовать `v` в последнем операторе `return`.)

.play flowcontrol/if-with-a-short-statement.go

* If и else

Переменные, объявленные внутри короткого оператора `if`, также доступны внутри любого
из блоков `else`.

(Оба вызова `pow` возвращают свои результаты до того, как начнется вызов `fmt.Println`
в `main`.)

.play flowcontrol/if-and-else.go

* Упражнение: Циклы и функции

В качестве способа поэкспериментировать с функциями и циклами, давайте реализуем функцию квадратного корня: для заданного числа x мы хотим найти число z, для которого z² наиболее близко к x.

Компьютеры обычно вычисляют квадратный корень из x с помощью цикла.
Начиная с некоторого предположения z, мы можем корректировать z в зависимости от того, насколько близко z² к x,
получая лучшее предположение:

	z -= (z*z - x) / (2*z)

Повторение этой корректировки делает предположение все лучше и лучше,
пока мы не достигнем ответа, который максимально близок к фактическому квадратному корню.

Реализуйте это в предоставленной функции `Sqrt`.
Хорошее начальное предположение для z — это 1, независимо от входных данных.
Для начала повторите вычисление 10 раз и выведите каждое z по ходу.
Посмотрите, насколько близко вы подходите к ответу для различных значений x (1, 2, 3, ...)
и как быстро улучшается предположение.

Подсказка: Чтобы объявить и инициализировать значение с плавающей точкой,
используйте синтаксис с плавающей точкой или преобразование:

	z := 1.0
	z := float64(1)

Затем измените условие цикла, чтобы остановиться, когда значение перестанет
изменяться (или изменяется только на очень малую величину).
Посмотрите, будет ли это больше или меньше 10 итераций.
Попробуйте другие начальные предположения для z, например x или x/2.
Насколько близки результаты вашей функции к [[https://go.dev/pkg/math/#Sqrt][math.Sqrt]] в стандартной библиотеке?

(*Примечание:* Если вас интересуют детали алгоритма, то z² − x выше
показывает, насколько далеко z² от того, где оно должно быть (x), а деление на 2z — это производная
от z², чтобы масштабировать, насколько мы корректируем z в зависимости от того, как быстро изменяется z².
Этот общий подход называется [[https://ru.wikipedia.org/wiki/Метод_Ньютона][методом Ньютона]].
Он хорошо работает для многих функций, но особенно хорошо для квадратного корня.)

.play flowcontrol/exercise-loops-and-functions.go

* Switch

Оператор `switch` — это более короткий способ написать последовательность операторов `if`-`else`.
Он выполняет первый случай, значение которого равно выражению условия.

`switch` в Go похож на тот, что в C, C++, Java, JavaScript и PHP,
за исключением того, что Go выполняет только выбранный случай, а не все последующие случаи.
По сути, оператор `break`, который нужен в конце каждого случая в тех
языках, в Go предоставляется автоматически.
Еще одно важное отличие заключается в том, что случаи `switch` в Go не обязательно
должны быть константами, а значения не обязательно должны быть целыми числами.

.play flowcontrol/switch.go

* Порядок вычисления в switch

Случаи в `switch` вычисляются сверху вниз, останавливаясь, когда случай успешен.

(Например,

	switch i {
	case 0:
	case f():
	}

не вызывает `f`, если `i==0`.)

#appengine: *Примечание:* Время в Go playground всегда начинается с
#appengine: 2009-11-10 23:00:00 UTC, значение, значимость которого оставлена как
#appengine: упражнение для читателя.

.play flowcontrol/switch-evaluation-order.go

* Switch без условия

`switch` без условия эквивалентен `switch true`.

Эта конструкция может быть чистым способом написать длинные цепочки if-then-else.

.play flowcontrol/switch-with-no-condition.go

* Defer

Оператор `defer` откладывает выполнение функции до возврата окружающей
функции.

Аргументы отложенного вызова вычисляются немедленно, но вызов функции
не выполняется до возврата окружающей функции.

.play flowcontrol/defer.go

* Накопление defer

Отложенные вызовы функций помещаются в стек. Когда функция возвращается, её
отложенные вызовы выполняются в порядке последним пришел — первым вышел.

Чтобы узнать больше об операторах defer, прочитайте эту
[[https://go.dev/blog/defer-panic-and-recover][статью в блоге]].

.play flowcontrol/defer-multi.go

* Поздравляем!

Вы завершили этот урок!

Вы можете вернуться к списку [[/tour/list][модулей]], чтобы найти, что изучать дальше, или продолжить со [[javascript:click('.next-page')][следующим уроком]].
