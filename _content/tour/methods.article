Методы и интерфейсы
Этот урок охватывает методы и интерфейсы — конструкции, которые определяют объекты и их поведение.

Авторы Go
https://golang.org

* Методы

В Go нет классов.
Однако вы можете определять методы для типов.

Метод — это функция со специальным аргументом _приёмника_.

Приёмник появляется в своем списке аргументов между ключевым словом `func` и
именем метода.

В этом примере метод `Abs` имеет приёмник типа `Vertex` с именем `v`.

.play methods/methods.go

* Методы — это функции

Помните: метод — это просто функция с аргументом приёмника.

Вот `Abs`, написанный как обычная функция без изменения функциональности.

.play methods/methods-funcs.go

* Методы (продолжение)

Вы также можете объявлять методы для типов, не являющихся структурами.

В этом примере мы видим числовой тип `MyFloat` с методом `Abs`.

Вы можете объявлять метод только с приёмником, тип которого определен в том же
пакете, что и метод.
Вы не можете объявлять метод с приёмником, тип которого определен в другом
пакете (что включает встроенные типы, такие как `int`).

.play methods/methods-continued.go

* Приёмники-указатели

Вы можете объявлять методы с приёмниками-указателями.

Это означает, что тип приёмника имеет литеральный синтаксис `*T` для некоторого типа `T`.
(Также `T` сам не может быть указателем, таким как `*int`.)

Например, метод `Scale` здесь определен для `*Vertex`.

Методы с приёмниками-указателями могут изменять значение, на которое указывает приёмник
(как это делает `Scale` здесь).
Поскольку методам часто нужно изменять свой приёмник, приёмники-указатели более
распространены, чем приёмники-значения.

Попробуйте удалить `*` из объявления функции `Scale` на строке 16
и посмотрите, как изменится поведение программы.

С приёмником-значением метод `Scale` работает с копией исходного
значения `Vertex`.
(Это то же поведение, что и для любого другого аргумента функции.)
Метод `Scale` должен иметь приёмник-указатель, чтобы изменить значение `Vertex`,
объявленное в функции `main`.

.play methods/methods-pointers.go

* Указатели и функции

Здесь мы видим методы `Abs` и `Scale`, переписанные как функции.

Снова попробуйте удалить `*` из строки 16.
Можете ли вы увидеть, почему поведение изменяется?
Что еще вам нужно было изменить, чтобы пример скомпилировался?

(Если вы не уверены, перейдите на следующую страницу.)

.play methods/methods-pointers-explained.go

* Методы и косвенное обращение к указателям

Сравнивая предыдущие две программы, вы можете заметить, что
функции с аргументом-указателем должны принимать указатель:

	var v Vertex
	ScaleFunc(v, 5)  // Ошибка компиляции!
	ScaleFunc(&v, 5) // OK

в то время как методы с приёмниками-указателями принимают либо значение, либо указатель в качестве
приёмника при вызове:

	var v Vertex
	v.Scale(5)  // OK
	p := &v
	p.Scale(10) // OK

Для оператора `v.Scale(5)`, даже если `v` — это значение, а не указатель,
метод с приёмником-указателем вызывается автоматически.
То есть, для удобства, Go интерпретирует оператор `v.Scale(5)` как
`(&v).Scale(5)`, поскольку метод `Scale` имеет приёмник-указатель.

.play methods/indirection.go

* Методы и косвенное обращение к указателям (2)

Эквивалентное происходит в обратном направлении.

Функции, которые принимают аргумент-значение, должны принимать значение этого конкретного типа:

	var v Vertex
	fmt.Println(AbsFunc(v))  // OK
	fmt.Println(AbsFunc(&v)) // Ошибка компиляции!

в то время как методы с приёмниками-значениями принимают либо значение, либо указатель в качестве
приёмника при вызове:

	var v Vertex
	fmt.Println(v.Abs()) // OK
	p := &v
	fmt.Println(p.Abs()) // OK

В этом случае вызов метода `p.Abs()` интерпретируется как `(*p).Abs()`.

.play methods/indirection-values.go

* Выбор приёмника-значения или приёмника-указателя

Есть две причины использовать приёмник-указатель.

Первая — чтобы метод мог изменять значение, на которое указывает его приёмник.

Вторая — чтобы избежать копирования значения при каждом вызове метода.
Это может быть более эффективно, если приёмник — большая структура, например.

В этом примере и `Scale`, и `Abs` — это методы с типом приёмника `*Vertex`,
хотя метод `Abs` не обязательно должен изменять свой приёмник.

В общем случае все методы для данного типа должны иметь либо приёмники-значения, либо приёмники-указатели,
но не смесь обоих.
(Мы увидим почему на следующих нескольких страницах.)

.play methods/methods-with-pointer-receivers.go

* Интерфейсы

_Тип интерфейса_ определяется как набор сигнатур методов.

Значение типа интерфейса может содержать любое значение, которое реализует эти методы.

*Примечание:* В примере кода на строке 22 есть ошибка.
`Vertex` (тип значения) не реализует `Abser`, потому что
метод `Abs` определен только для `*Vertex` (тип указателя).

.play methods/interfaces.go

* Интерфейсы реализуются неявно

Тип реализует интерфейс, реализуя его методы.
Нет явного объявления намерения, нет ключевого слова "implements".

Неявные интерфейсы разделяют определение интерфейса и его
реализацию, которая затем может появиться в любом пакете без предварительной договоренности.

.play methods/interfaces-are-satisfied-implicitly.go

* Значения интерфейсов

Под капотом значения интерфейсов можно рассматривать как кортеж значения и
конкретного типа:

	(value, type)

Значение интерфейса содержит значение определенного базового конкретного типа.

Вызов метода для значения интерфейса выполняет метод с тем же именем для
его базового типа.

.play methods/interface-values.go

* Значения интерфейсов с nil базовыми значениями

Если конкретное значение внутри интерфейса само по себе равно nil,
метод будет вызван с nil приёмником.

В некоторых языках это вызвало бы исключение null pointer,
но в Go принято писать методы, которые корректно обрабатывают вызов
с nil приёмником (как в методе `M` в этом примере).

Обратите внимание, что значение интерфейса, которое содержит nil конкретное значение, само по себе не nil.

.play methods/interface-values-with-nil.go

* Nil значения интерфейсов

Nil значение интерфейса не содержит ни значения, ни конкретного типа.

Вызов метода для nil интерфейса — это ошибка времени выполнения, потому что нет
типа внутри кортежа интерфейса, чтобы указать, какой _конкретный_ метод вызывать.

.play methods/nil-interface-values.go

* Пустой интерфейс

Тип интерфейса, который указывает ноль методов, известен как _пустой интерфейс_:

	interface{}

Пустой интерфейс может содержать значения любого типа.
(Каждый тип реализует по крайней мере ноль методов.)

Пустые интерфейсы используются кодом, который обрабатывает значения неизвестного типа.
Например, `fmt.Print` принимает любое количество аргументов типа `interface{}`.

.play methods/empty-interface.go

* Проверки типов

_Проверка типа_ предоставляет доступ к базовому конкретному значению значения интерфейса.

	t := i.(T)

Этот оператор утверждает, что значение интерфейса `i` содержит конкретный тип `T`
и присваивает базовое значение `T` переменной `t`.

Если `i` не содержит `T`, оператор вызовет панику.

Чтобы _проверить_, содержит ли значение интерфейса определенный тип,
проверка типа может возвращать два значения: базовое значение
и логическое значение, которое сообщает, успешна ли проверка.

	t, ok := i.(T)

Если `i` содержит `T`, то `t` будет базовым значением, а `ok` будет true.

Если нет, `ok` будет false, а `t` будет нулевым значением типа `T`,
и паника не произойдет.

Обратите внимание на сходство между этим синтаксисом и чтением из хэш-таблицы.

.play methods/type-assertions.go

* Переключатели типов

_Переключатель типов_ — это конструкция, которая позволяет выполнять несколько проверок типов подряд.

Переключатель типов похож на обычный оператор switch, но случаи в переключателе типов
указывают типы (а не значения), и эти значения сравниваются с
типом значения, содержащегося в данном значении интерфейса.

	switch v := i.(type) {
	case T:
		// здесь v имеет тип T
	case S:
		// здесь v имеет тип S
	default:
		// нет совпадения; здесь v имеет тот же тип, что и i
	}

Объявление в переключателе типов имеет тот же синтаксис, что и проверка типа `i.(T)`,
но конкретный тип `T` заменен ключевым словом `type`.

Этот оператор switch проверяет, содержит ли значение интерфейса `i`
значение типа `T` или `S`.
В каждом из случаев `T` и `S` переменная `v` будет иметь тип
`T` или `S` соответственно и содержать значение, содержащееся в `i`.
В случае по умолчанию (где нет совпадения) переменная `v` имеет
тот же тип интерфейса и значение, что и `i`.

.play methods/type-switches.go

* Stringers

Один из самых распространенных интерфейсов — это [[https://go.dev/pkg/fmt/#Stringer][`Stringer`]], определенный пакетом [[https://go.dev/pkg/fmt/][`fmt`]].

	type Stringer interface {
		String() string
	}

`Stringer` — это тип, который может описать себя как строку. Пакет `fmt`
(и многие другие) ищут этот интерфейс для вывода значений.

.play methods/stringer.go

* Упражнение: Stringers

Заставьте тип `IPAddr` реализовать `fmt.Stringer`, чтобы выводить адрес в виде
точечной четверки.

Например, `IPAddr{1,`2,`3,`4}` должен выводиться как `"1.2.3.4"`.

.play methods/exercise-stringer.go

* Ошибки

Программы Go выражают состояние ошибки значениями `error`.

Тип `error` — это встроенный интерфейс, похожий на `fmt.Stringer`:

	type error interface {
		Error() string
	}

(Как и с `fmt.Stringer`, пакет `fmt` ищет интерфейс `error` при
выводе значений.)

Функции часто возвращают значение `error`, и вызывающий код должен обрабатывать ошибки,
проверяя, равен ли error `nil`.

	i, err := strconv.Atoi("42")
	if err != nil {
		fmt.Printf("не удалось преобразовать число: %v\n", err)
		return
	}
	fmt.Println("Преобразованное целое число:", i)

Nil `error` обозначает успех; ненулевой `error` обозначает неудачу.

.play methods/errors.go

* Упражнение: Ошибки

Скопируйте вашу функцию `Sqrt` из [[/tour/flowcontrol/8][предыдущего упражнения]] и измените её, чтобы она возвращала значение `error`.

`Sqrt` должна возвращать ненулевое значение ошибки, когда ей дано отрицательное число, так как она не поддерживает комплексные числа.

Создайте новый тип

	type ErrNegativeSqrt float64

и сделайте его `error`, дав ему

	func (e ErrNegativeSqrt) Error() string

метод, такой что `ErrNegativeSqrt(-2).Error()` возвращает `"cannot`Sqrt`negative`number:`-2"`.

*Примечание:* Вызов `fmt.Sprint(e)` внутри метода `Error` отправит программу в бесконечный цикл. Вы можете избежать этого, сначала преобразовав `e`: `fmt.Sprint(float64(e))`. Почему?

Измените вашу функцию `Sqrt`, чтобы она возвращала значение `ErrNegativeSqrt`, когда ей дано отрицательное число.

.play methods/exercise-errors.go

* Readers

Пакет `io` определяет интерфейс `io.Reader`,
который представляет конец чтения потока данных.

Стандартная библиотека Go содержит [[https://cs.opensource.google/search?q=Read%5C(%5Cw%2B%5Cs%5C%5B%5C%5Dbyte%5C)&ss=go%2Fgo][множество реализаций]] этого интерфейса, включая файлы, сетевые соединения, компрессоры, шифры и другие.

Интерфейс `io.Reader` имеет метод `Read`:

	func (T) Read(b []byte) (n int, err error)

`Read` заполняет данный байтовый срез данными и возвращает количество байтов,
заполненных данными, и значение ошибки. Он возвращает ошибку `io.EOF`, когда поток
заканчивается.

Пример кода создает
[[https://go.dev/pkg/strings/#Reader][`strings.Reader`]]
и потребляет его вывод по 8 байт за раз.

.play methods/reader.go

* Упражнение: Readers

Реализуйте тип `Reader`, который выдает бесконечный поток символа ASCII
`'A'`.

.play methods/exercise-reader.go

* Упражнение: rot13Reader

Распространенный паттерн — это [[https://go.dev/pkg/io/#Reader][io.Reader]], который оборачивает другой `io.Reader`, изменяя поток каким-то образом.

Например, функция [[https://go.dev/pkg/compress/gzip/#NewReader][gzip.NewReader]] принимает `io.Reader` (поток сжатых данных) и возвращает `*gzip.Reader`, который также реализует `io.Reader` (поток распакованных данных).

Реализуйте `rot13Reader`, который реализует `io.Reader` и читает из `io.Reader`, изменяя поток путем применения [[https://ru.wikipedia.org/wiki/ROT13][rot13]] подстановочного шифра ко всем буквенным символам.

Тип `rot13Reader` предоставлен вам.
Сделайте его `io.Reader`, реализовав его метод `Read`.

.play methods/exercise-rot-reader.go

* Images

[[https://go.dev/pkg/image/#Image][Пакет image]] определяет интерфейс `Image`:

	package image

	type Image interface {
		ColorModel() color.Model
		Bounds() Rectangle
		At(x, y int) color.Color
	}

*Примечание*: возвращаемое значение `Rectangle` метода `Bounds` на самом деле является
[[https://go.dev/pkg/image/#Rectangle][`image.Rectangle`]], так как
объявление находится внутри пакета `image`.

(См. [[https://go.dev/pkg/image/#Image][документацию]] для всех деталей.)

Типы `color.Color` и `color.Model` также являются интерфейсами, но мы проигнорируем это, используя предопределенные реализации `color.RGBA` и `color.RGBAModel`. Эти интерфейсы и типы указаны в [[https://go.dev/pkg/image/color/][пакете image/color]].

.play methods/images.go

* Упражнение: Images

Помните [[/tour/moretypes/18][генератор картинок]], который вы писали ранее? Давайте напишем еще один, но на этот раз он будет возвращать реализацию `image.Image` вместо среза данных.

Определите свой собственный тип `Image`, реализуйте [[https://go.dev/pkg/image/#Image][необходимые методы]] и вызовите `pic.ShowImage`.

`Bounds` должен возвращать `image.Rectangle`, например `image.Rect(0,`0,`w,`h)`.

`ColorModel` должен возвращать `color.RGBAModel`.

`At` должен возвращать цвет; значение `v` в последнем генераторе картинок соответствует `color.RGBA{v,`v,`255,`255}` в этом.

.play methods/exercise-images.go

* Поздравляем!

Вы завершили этот урок!

Вы можете вернуться к списку [[/tour/list][модулей]], чтобы найти, что изучать дальше, или продолжить со [[javascript:click('.next-page')][следующим уроком]].
