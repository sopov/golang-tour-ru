Дополнительные типы: struct, slice и map.
Изучите, как определять типы на основе существующих: этот урок охватывает struct, array, slice и map.

Авторы Go
https://golang.org

* Указатели

В Go есть указатели.
Указатель хранит адрес памяти значения.

Тип `*T` — это указатель на значение типа `T`. Его нулевое значение — `nil`.

	var p *int

Оператор `&` генерирует указатель на свой операнд.

	i := 42
	p = &i

Оператор `*` обозначает базовое значение указателя.

	fmt.Println(*p) // читаем i через указатель p
	*p = 21         // устанавливаем i через указатель p

Это называется "разыменованием" или "косвенным обращением".

В отличие от C, в Go нет арифметики указателей.

.play moretypes/pointers.go

* Структуры

`struct` — это коллекция полей.

.play moretypes/structs.go

* Поля структуры

К полям структуры обращаются с помощью точки.

.play moretypes/struct-fields.go

* Указатели на структуры

К полям структуры можно обращаться через указатель на структуру.

Чтобы получить доступ к полю `X` структуры, когда у нас есть указатель на структуру `p`, мы могли бы
написать `(*p).X`.
Однако эта нотация громоздка, поэтому язык позволяет нам вместо этого
просто написать `p.X`, без явного разыменования.

.play moretypes/struct-pointers.go

* Литералы структур

Литерал структуры обозначает вновь выделенное значение структуры путем перечисления значений её полей.

Вы можете перечислить только подмножество полей, используя синтаксис `Name:`. (И порядок именованных полей не имеет значения.)

Специальный префикс `&` возвращает указатель на значение структуры.

.play moretypes/struct-literals.go


* Массивы

Тип `[n]T` — это массив из `n` значений типа `T`.

Выражение

	var a [10]int

объявляет переменную `a` как массив из десяти целых чисел.

Длина массива является частью его типа, поэтому массивы нельзя изменять по размеру.
Это может показаться ограничением, но не волнуйтесь;
Go предоставляет удобный способ работы с массивами.

.play moretypes/array.go


* Срезы

Массив имеет фиксированный размер.
Срез, с другой стороны, — это динамически изменяемый,
гибкий вид элементов массива.
На практике срезы встречаются гораздо чаще, чем массивы.

Тип `[]T` — это срез с элементами типа `T`.

Срез формируется путем указания двух индексов, нижней и
верхней границы, разделенных двоеточием:

	a[low : high]

Это выбирает полуоткрытый диапазон, который включает первый
элемент, но исключает последний.

Следующее выражение создает срез, который включает
элементы с 1 по 3 из `a`:

	a[1:4]

.play moretypes/slices.go


* Срезы похожи на ссылки на массивы

Срез не хранит никаких данных,
он просто описывает секцию базового массива.

Изменение элементов среза изменяет
соответствующие элементы его базового массива.

Другие срезы, которые используют тот же базовый массив, увидят эти изменения.

.play moretypes/slices-pointers.go


* Литералы срезов

Литерал среза похож на литерал массива без указания длины.

Это литерал массива:

	[3]bool{true, true, false}

А это создает тот же массив, что и выше,
затем строит срез, который ссылается на него:

	[]bool{true, true, false}

.play moretypes/slice-literals.go


* Значения по умолчанию для срезов

При создании среза вы можете опустить верхнюю или нижнюю границу, чтобы использовать их значения по умолчанию.

Значение по умолчанию — ноль для нижней границы и длина среза для верхней границы.

Для массива

	var a [10]int

эти выражения срезов эквивалентны:

	a[0:10]
	a[:10]
	a[0:]
	a[:]

.play moretypes/slice-bounds.go


* Длина и емкость среза

Срез имеет как _длину_, так и _емкость_.

Длина среза — это количество элементов, которые он содержит.

Емкость среза — это количество элементов в базовом массиве,
начиная с первого элемента в срезе.

Длину и емкость среза `s` можно получить с помощью выражений
`len(s)` и `cap(s)`.

Вы можете расширить длину среза, пересоздав его,
при условии, что у него достаточно емкости.
Попробуйте изменить одну из операций со срезом в примере программы, чтобы расширить его
за пределы его емкости, и посмотрите, что произойдет.

.play moretypes/slice-len-cap.go


* Nil срезы

Нулевое значение среза — `nil`.

Nil срез имеет длину и емкость 0
и не имеет базового массива.

.play moretypes/nil-slices.go


* Создание среза с помощью make

Срезы можно создавать с помощью встроенной функции `make`;
вот как вы создаете динамически изменяемые массивы.

Функция `make` выделяет обнуленный массив
и возвращает срез, который ссылается на этот массив:

	a := make([]int, 5)  // len(a)=5

Чтобы указать емкость, передайте третий аргумент в `make`:

	b := make([]int, 0, 5) // len(b)=0, cap(b)=5

	b = b[:cap(b)] // len(b)=5, cap(b)=5
	b = b[1:]      // len(b)=4, cap(b)=4

.play moretypes/making-slices.go


* Срезы срезов

Срезы могут содержать любой тип, включая другие срезы.

.play moretypes/slices-of-slice.go


* Добавление элементов в срез

Часто требуется добавлять новые элементы в срез, поэтому Go предоставляет встроенную
функцию `append`. [[https://go.dev/pkg/builtin/#append][Документация]]
встроенного пакета описывает `append`.

	func append(s []T, vs ...T) []T

Первый параметр `s` функции `append` — это срез типа `T`, а остальные —
значения типа `T` для добавления в срез.

Результирующее значение `append` — это срез, содержащий все элементы
исходного среза плюс предоставленные значения.

Если базовый массив `s` слишком мал, чтобы вместить все заданные значения, будет
выделен больший массив. Возвращаемый срез будет указывать на вновь выделенный
массив.

(Чтобы узнать больше о срезах, прочитайте статью [[https://go.dev/blog/go-slices-usage-and-internals][Срезы: использование и внутреннее устройство]].)

.play moretypes/append.go


* Range

Форма `range` цикла `for` итерируется по срезу или хэш-таблице.

При итерации по срезу для каждой итерации возвращаются два значения.
Первое — это индекс, а второе — копия элемента по этому индексу.

.play moretypes/range.go

* Range (продолжение)

Вы можете пропустить индекс или значение, присвоив `_`.

    for i, _ := range pow
    for _, value := range pow

Если вам нужен только индекс, вы можете опустить вторую переменную.

    for i := range pow

.play moretypes/range-continued.go

* Упражнение: Срезы

Реализуйте `Pic`. Она должна возвращать срез длины `dy`, каждый элемент которого является срезом из `dx` 8-битных беззнаковых целых чисел. Когда вы запустите программу, она отобразит вашу картинку, интерпретируя целые числа как значения градаций серого (ну, скорее синего).

Выбор изображения зависит от вас. Интересные функции включают `(x+y)/2`, `x*y` и `x^y`.

(Вам нужно использовать цикл для выделения каждого `[]uint8` внутри `[][]uint8`.)

(Используйте `uint8(intValue)` для преобразования между типами.)

.play moretypes/exercise-slices.go

* Хэш-таблицы

Хэш-таблица сопоставляет ключи со значениями.

Нулевое значение map — `nil`.
У map `nil` нет ключей, и в неё нельзя добавлять ключи.

Функция `make` возвращает map заданного типа,
инициализированную и готовую к использованию.

.play moretypes/maps.go

* Литералы map

Литералы хэш-таблиц похожи на литералы структур, но ключи обязательны.

.play moretypes/map-literals.go

* Литералы map (продолжение)

Если тип верхнего уровня — это просто имя типа, вы можете опустить его из элементов литерала хэш-таблицы.

.play moretypes/map-literals-continued.go

* Изменение map

Вставить или обновить элемент в хэш-таблице `m`:

	m[key] = elem

Получить элемент:

	elem = m[key]

Удалить элемент:

	delete(m, key)

Проверить наличие ключа с помощью присваивания с двумя значениями:

	elem, ok = m[key]

Если `key` находится в `m`, то `ok` равно `true`. Если нет, то `ok` равно `false`.

Если `key` отсутствует в хэш-таблице, то `elem` — это нулевое значение для типа элемента map.

*Примечание:* Если `elem` или `ok` еще не объявлены, вы можете использовать форму короткого объявления:

	elem, ok := m[key]

.play moretypes/mutating-maps.go

* Упражнение: Maps

Реализуйте `WordCount`. Она должна возвращать хэш-таблицу подсчетов каждого "слова" в строке `s`. Функция `wc.Test` запускает набор тестов против предоставленной функции и выводит успех или неудачу.

Вам может пригодиться [[https://go.dev/pkg/strings/#Fields][strings.Fields]].

.play moretypes/exercise-maps.go

* Значения функций

Функции тоже являются значениями. Их можно передавать так же, как и другие значения.

Значения функций могут использоваться как аргументы функций и возвращаемые значения.

.play moretypes/function-values.go

* Замыкания функций

Функции Go могут быть замыканиями. Замыкание — это значение функции, которое ссылается на переменные извне её тела. Функция может обращаться к ссылочным переменным и присваивать им значения; в этом смысле функция "привязана" к переменным.

Например, функция `adder` возвращает замыкание. Каждое замыкание привязано к своей собственной переменной `sum`.

.play moretypes/function-closures.go

* Упражнение: Замыкание Фибоначчи

Давайте немного повеселимся с функциями.

Реализуйте функцию `fibonacci`, которая возвращает функцию (замыкание), которая
возвращает последовательные [[https://ru.wikipedia.org/wiki/Числа_Фибоначчи][числа Фибоначчи]]
(0, 1, 1, 2, 3, 5, ...).

.play moretypes/exercise-fibonacci-closure.go

* Поздравляем!

Вы завершили этот урок!

Вы можете вернуться к списку [[/tour/list][модулей]], чтобы найти, что изучать дальше, или продолжить со [[javascript:click('.next-page')][следующим уроком]].
